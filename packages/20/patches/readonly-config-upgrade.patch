commit 7ab4d0dc9cbada00bf25afaef294349b08c70d75
Author: aszlig <aszlig@nix.build>
Date:   Thu Feb 28 16:01:13 2019 +0100

    Allow to upgrade if the config is read-only
    
    We don't need to put the instance into maintenance mode because the
    updater runs during NixOS activation and the unit file ordering prevents
    the cron and main Nextcloud services from being started during an
    upgrade or after a failed upgrade.
    
    So if the config isn't writable, let's just pretend that we have written
    to the config file.
    
    Signed-off-by: aszlig <aszlig@nix.build>

diff --git a/lib/base.php b/lib/base.php
index c42f427ca4..384797d43f 100644
--- a/lib/base.php
+++ b/lib/base.php
@@ -243,8 +243,7 @@ class OC {
 
 		// Check if config is writable
 		$configFileWritable = is_writable($configFilePath);
-		if (!$configFileWritable && !OC_Helper::isReadOnlyConfigEnabled()
-			|| !$configFileWritable && \OCP\Util::needUpgrade()) {
+		if (!$configFileWritable && !OC_Helper::isReadOnlyConfigEnabled()) {
 			$urlGenerator = \OC::$server->getURLGenerator();
 
 			if (self::$CLI) {
diff --git a/lib/private/Config.php b/lib/private/Config.php
index a6c4acb7d9..27dc72985c 100644
--- a/lib/private/Config.php
+++ b/lib/private/Config.php
@@ -238,6 +238,13 @@ class Config {
 	 * @throws \Exception If no file lock can be acquired
 	 */
 	private function writeData() {
+		// We have removed the check whether the config file is writable for
+		// non-up-to-date versions in lib/base.php, but in order to update
+		// anyway, we need to make sure that we don't actually write the data
+		// if we have a config file that resides within a Nix store path.
+		if (!is_writable($this->configFilePath))
+			return;
+
 		// Create a php file ...
 		$content = "<?php\n";
 		$content .= '$CONFIG = ';
diff --git a/lib/private/Updater.php b/lib/private/Updater.php
index a871194434..cf42b7562f 100644
--- a/lib/private/Updater.php
+++ b/lib/private/Updater.php
@@ -261,19 +261,6 @@ class Updater extends BasicEmitter {
 		$this->checkAppsRequirements();
 		$this->doAppUpgrade();
 
-		// Update the appfetchers version so it downloads the correct list from the appstore
-		\OC::$server->getAppFetcher()->setVersion($currentVersion);
-
-		/** @var IAppManager|AppManager $appManager */
-		$appManager = \OC::$server->getAppManager();
-
-		// upgrade appstore apps
-		$this->upgradeAppStoreApps($appManager->getInstalledApps());
-		$autoDisabledApps = $appManager->getAutoDisabledApps();
-		if (!empty($autoDisabledApps)) {
-			$this->upgradeAppStoreApps(array_keys($autoDisabledApps), $autoDisabledApps);
-		}
-
 		// install new shipped apps on upgrade
 		$errors = Installer::installShippedApps(true);
 		foreach ($errors as $appId => $exception) {
